"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHistoricalData = exports.Options = undefined;

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var getHistoricalData = exports.getHistoricalData = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(date) {
    var options, data, json;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = new Options(date).requestObject;
            _context.prev = 1;
            _context.next = 4;
            return (0, _requestPromise2.default)(options);

          case 4:
            data = _context.sent;

            if (!(data.statusCode == 200)) {
              _context.next = 10;
              break;
            }

            json = _csvjson2.default.toObject(data.body);
            return _context.abrupt("return", _promise2.default.resolve(json));

          case 10:
            if (!(data.statusCode == 404)) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return", _promise2.default.resolve({}));

          case 12:
            _context.next = 17;
            break;

          case 14:
            _context.prev = 14;
            _context.t0 = _context["catch"](1);
            return _context.abrupt("return", _promise2.default.reject(_context.t0));

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 14]]);
  }));

  return function getHistoricalData(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.indexNamesChecker = indexNamesChecker;
exports.dateRangeChecker = dateRangeChecker;
exports.metricsChecker = metricsChecker;
exports.wayChecker = wayChecker;

var _lodash = require("lodash");

var _momentTimezone = require("moment-timezone");

var _momentTimezone2 = _interopRequireDefault(_momentTimezone);

var _requestPromise = require("request-promise");

var _requestPromise2 = _interopRequireDefault(_requestPromise);

var _csvjson = require("csvjson");

var _csvjson2 = _interopRequireDefault(_csvjson);

var _Indices = require("./Indices");

var _Indices2 = _interopRequireDefault(_Indices);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var url = (0, _lodash.template)("https://www.nseindia.com/content/indices/ind_close_all_${datestamp}.csv");

var Options = exports.Options = function () {
  function Options(date) {
    (0, _classCallCheck3.default)(this, Options);

    this.method = "GET";
    this.uri = url({ datestamp: date });
  }

  (0, _createClass3.default)(Options, [{
    key: "requestObject",
    get: function get() {
      return {
        method: this.method,
        uri: this.uri,
        headers: {
          "User-Agent": "request-promise",
          Connection: "keep-alive"
        },
        json: true,
        resolveWithFullResponse: true
      };
    }
  }]);
  return Options;
}();

function indexNamesChecker(indexNames) {
  var allowedIndexNames = [];

  (0, _lodash.forEach)(_Indices2.default, function (indexObject) {
    allowedIndexNames.push(indexObject.name);
  });

  if (typeof indexNames === "string" && indexNames.replace(/\s/g, "").toLowerCase() === "all") {
    return allowedIndexNames;
  }

  var formattedIndexNames = [];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var indexName = _step.value;

      var index = (0, _lodash.find)(allowedIndexNames, function (allowedIndexName) {
        return allowedIndexName.replace(/\s/g, "").toLowerCase() === indexName.replace(/\s/g, "").toLowerCase();
      });

      if (index) {
        formattedIndexNames.push(index);
      } else {
        var err = (0, _lodash.template)('indexName "${indexName}" do not exist');
        throw new Error(err({ indexNames: index }));
      }
    };

    for (var _iterator = (0, _getIterator3.default)(indexNames), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return formattedIndexNames;
}

function dateRangeChecker(dateRange) {
  var fromDate = void 0,
      toDate = void 0;

  if (!dateRange.hasOwnProperty("start")) {
    throw new Error("dateRange.start not defined");
  } else {
    try {
      fromDate = (0, _momentTimezone2.default)(dateRange.start).tz("Asia/Kolkata");
    } catch (err) {
      throw err;
    }
  }

  if (!dateRange.hasOwnProperty("end")) {
    toDate = (0, _momentTimezone2.default)().tz("Asia/Kolkata").subtract(1, "days");
  } else {
    try {
      toDate = (0, _momentTimezone2.default)(dateRange.end).tz("Asia/Kolkata");
    } catch (err) {
      throw err;
    }
  }

  return { start: fromDate, end: toDate };
}

function metricsChecker(metrics) {
  var allowedMetrics = ["pb", "pe", "dy", "high", "low", "open", "close", "volume", "turnover"];

  if (typeof metrics === "string" && metrics.replace(/\s/g, "").toLowerCase() === "all") {
    return allowedMetrics;
  }

  var wantedMetrics = {};

  (0, _lodash.forEach)(allowedMetrics, function (metric) {
    wantedMetrics[metric] = false;
  });

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)(metrics), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var metric = _step2.value;

      if ((0, _lodash.indexOf)(allowedMetrics, metric) < 0) {
        var err = (0, _lodash.template)('metric "${metric}" does not exist');
        throw new Error(err({ metric: metric }));
      } else {
        wantedMetrics[metric] = true;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return wantedMetrics;
}

function wayChecker(way) {
  var allowedWays = ["datewise", "metricwise", "indexwise"];

  if ((0, _lodash.indexOf)(allowedWays, way) < 0) {
    var err = (0, _lodash.template)('Formatting type "${way}" does not exist');
    throw new Error(err({ way: way }));
  } else {
    return way;
  }
}
//# sourceMappingURL=Helper.js.map